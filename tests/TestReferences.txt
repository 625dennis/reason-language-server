=== Basic
let <c1>x = 10;
let y = <t1>x + <t1>x;
type <c4>record = {
  <c2>name: string,
};
type m = <t4>record;
let me = {<t2>name: "Hi"};
switch None {
  | Some({<t2><t3>name}) => print_endline(<c3>name)
  | _ => ()
};
-->
  1: PASS
  2: PASS
  3: PASS
  4: PASS

=== Mutable
type r = {
  mutable <t1><c2>n: string,
};
let m = {<c1><t2>n: "hello"};
-->
  1: PASS
  2: PASS

=== Constructor
type a = | <c1>A(int) | <t2>B(float);
let b = <t1>A(1);
let c = <t1>A(3);
let d = <c2>B(1.);

-->
  1: PASS
  2: PASS

=== Basic cross-module
--- Lib.re
let <c1>x = 10;
---
let y = <t1>Lib.x;

-->
  1: PASS

=== Cross-module Constructor
--- Lib.re
type a = | <c1>A(int) | B(float);
let b = <t1>A(1);
let c = <t1>A(3);
---
let m = <t1>Lib.A(2);
-->
  1: PASS

=== Cross-module with same-name export
--- Lib.re
type a = | <c1>A(int) | B(float);
let a = <t1>A(1);
let c = <t1>A(3);
---
let m = Lib.<t1>A(2);
-->
  1: FAIL
    missing reference - file:///path/to/Test.re 12 (1, 12)
    extra ref - file:///path/to/Test.re 8 (1, 8)


=== Kitchen sink
--- Other.re
let thing = {Lib.<t2>name: "hi", <t3>age: 2};
let contain = {Lib.v: B({<t2>name: "inner", <t3>age: 1}), r: {<t2>name: "one", <t3>age: 5}};
--- Lib.re
type <c1>record = {
  <c2>name: string,
  <c3>age: int
};
type variant = <c4>A(int, float) | B(record);
type container = {v: variant, r: <t1>record};
let here = {<t2>name: "fred", <t3>age: 3};
let a = <t4>A(3, 4.);
---
/*
let awesome_awesome = 10;
let m = awesome_awesome;
let z = string_of_int(m);
Other.contain.r.<t3>age;
let m = <t4>A(2,3);
*/
-->
  1: FAIL
    extra ref - file:///path/to/Lib.re 79 (5, 33)

  2: FAIL
    missing reference - file:///path/to/Other.re 17 (1, 17)
    extra ref - file:///path/to/Other.re 13 (1, 13)

  3: FAIL
    missing reference - file:///path/to/Test.re 96 (5, 16)

  4: FAIL
    missing reference - file:///path/to/Test.re 109 (6, 8)

